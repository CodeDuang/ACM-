题目描述：
  lyd学会了使用扑克DIY占卜。方法如下：一副去掉大小王的扑克共52张，打乱后均分为13堆，编号1~13，每 堆4张，其中第13堆称作“生命牌”，也就是说你有4条命。这里边，4张K被称作死神。 初始状态下，所有的牌背面朝上扣下。 流程如下： 1.抽取生命牌中的最上面一张(第一张)。 2.把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。(例如抽到2，正面朝上放到第2堆牌最 上面，又比如抽到J，放到第11堆牌最上边，注意是正面朝上放) 3.从刚放了牌的那一堆最底下(最后一张)抽取一张牌，重复第2步。（例如你上次抽了2，放到了第二堆顶部，现 在抽第二堆最后一张发现是8，又放到第8堆顶部.........）
4.在抽牌过程中如果抽到K，则称死了一条命，就扔掉K再从第1步开始。 5.当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现4张正面朝上的 牌(比如4个A)，则称“开了一对”，当然4个K是不算的。 6.统计一共开了多少对，开了0对称作"极凶"，1~2对为“大凶”，3对为“凶”，4~5对为“小凶”，6对为“中庸”， 7~8对“小吉”，9对为“吉”，10~11为“大吉”，12为“满堂开花，极吉”。
如果还不明白，就去看样例把。。。
输入：
  一共13行，为每堆牌的具体牌是什么(不区分花色只区分数字)，每堆输入的顺序为从上到下。 为了便于读入，用0代表10，那么A，J，Q，K(大写)就不用说了吧。。。
输出：
  一共开了几对。
  
样例输入：
8 5 A A 
K 5 3 2 
9 6 0 6 
3 4 3 4 
3 4 4 5 
5 6 7 6 
8 7 7 7 
9 9 8 8 
9 0 0 0 
K J J J 
Q A Q K 
J Q 2 2 
A K Q 2

样例输出：
9

代码实现：
#include<stdio.h>

int game(char a[13][4])
{
	int i, j, num = 0;
	char *p, *q, t;
	for(j = 0; j < 4; j++)
	{
		p = &a[12][j];
		H1:switch(*p)
		{
		case 'A' : q = &a[0][3]; break;
		case '2' : q = &a[1][3]; break;
		case '3' : q = &a[2][3]; break;
		case '4' : q = &a[3][3]; break;
		case '5' : q = &a[4][3]; break;
		case '6' : q = &a[5][3]; break;
		case '7' : q = &a[6][3]; break;
		case '8' : q = &a[7][3]; break;
		case '9' : q = &a[8][3]; break;
		case '0' : q = &a[9][3]; break;
		case 'J' : q = &a[10][3]; break;
		case 'Q' : q = &a[11][3]; break;
		case 'K' : q = &a[12][0]; break;
												
		}
		if(*p != 'K')
		{
			t = *q;             //抽出最下面的牌（除了K）
			*q= *(q - 1);       //将上面三张牌依次向下移动
			*(q - 1)= *(q - 2);
			*(q - 2)= *(q - 3);
			q = q - 3;          //将正面牌变为‘K’，以便后面计数
			*q = 'K';
			*p = t;
			goto H1;
		}
	}
	for(i = 0; i < 12; i++)
	{
		if(a[i][3] == 'K') num += 1;
	}
	return num;
}

void main()
{
	int i, j;
	char a[13][4];
	for(i = 0; i < 13; i++)
	{
		for(j = 0; j < 4; j++)
		{
			
			a[i][j] = getchar();
			getchar();
			
			
		}
		getchar();
	}
	printf("%d", game(a));

}
